{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utilities.ts", "../src/graphql.ts"],
  "sourcesContent": ["export { filter, check, propType } from './utilities';\n\nexport {\n  Resolver,\n  VariableMap,\n  ResultMapper,\n  FragmentMatcher,\n  ExecContext,\n  ExecInfo,\n  ExecOptions,\n} from './graphql';\n\nimport { graphql } from './graphql';\nexport default graphql;\n", "import { DocumentNode, DirectiveNode } from 'graphql';\n\nimport { getInclusionDirectives } from 'apollo-utilities';\n\nimport { graphql, VariableMap, ExecInfo, ExecContext } from './graphql';\n\nimport { invariant } from 'ts-invariant';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport function filter<FD = any, D extends FD = any>(\n  doc: DocumentNode,\n  data: D,\n  variableValues: VariableMap = {},\n): FD {\n  if (data === null) return data;\n\n  const resolver = (\n    fieldName: string,\n    root: any,\n    args: Object,\n    context: ExecContext,\n    info: ExecInfo,\n  ) => {\n    return root[info.resultKey];\n  };\n\n  return Array.isArray(data)\n    ? data.map(dataObj => graphql(resolver, doc, dataObj, null, variableValues))\n    : graphql(resolver, doc, data, null, variableValues);\n}\n\n// TODO: we should probably make check call propType and then throw,\n// rather than the other way round, to avoid constructing stack traces\n// for things like oneOf uses in React. At this stage I doubt many people\n// are using this like that, but in the future, who knows?\nexport function check(\n  doc: DocumentNode,\n  data: any,\n  variables: VariableMap = {},\n): void {\n  const resolver = (\n    fieldName: string,\n    root: any,\n    args: any,\n    context: any,\n    info: any,\n  ) => {\n    // When variables is null, fields with @include/skip directives that\n    // reference variables are considered optional.\n    invariant(\n      hasOwnProperty.call(root, info.resultKey) ||\n        (!variables && hasVariableInclusions(info.field.directives)),\n      `${info.resultKey} missing on ${JSON.stringify(root)}`,\n    );\n    return root[info.resultKey];\n  };\n\n  graphql(resolver, doc, data, {}, variables, {\n    fragmentMatcher: () => false,\n  });\n}\n\nfunction hasVariableInclusions(\n  directives: ReadonlyArray<DirectiveNode>,\n): boolean {\n  return getInclusionDirectives(directives).some(\n    ({ ifArgument }) =>\n      ifArgument.value && ifArgument.value.kind === 'Variable',\n  );\n}\n\n// Lifted/adapted from\n//   https://github.com/facebook/react/blob/master/src/isomorphic/classic/types/ReactPropTypes.js\nconst ANONYMOUS = '<<anonymous>>';\nfunction PropTypeError(message) {\n  this.message = message;\n  this.stack = '';\n}\n// Make `instanceof Error` still work for returned errors.\nPropTypeError.prototype = Error.prototype;\n\nconst reactPropTypeLocationNames = {\n  prop: 'prop',\n  context: 'context',\n  childContext: 'child context',\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(\n    isRequired,\n    props,\n    propName,\n    componentName,\n    location,\n    propFullName,\n  ) {\n    componentName = componentName || ANONYMOUS;\n    propFullName = propFullName || propName;\n    if (props[propName] == null) {\n      const locationName = reactPropTypeLocationNames[location];\n      if (isRequired) {\n        if (props[propName] === null) {\n          return new PropTypeError(\n            `The ${locationName} \\`${propFullName}\\` is marked as required ` +\n              `in \\`${componentName}\\`, but its value is \\`null\\`.`,\n          );\n        }\n        return new PropTypeError(\n          `The ${locationName} \\`${propFullName}\\` is marked as required in ` +\n            `\\`${componentName}\\`, but its value is \\`undefined\\`.`,\n        );\n      }\n      return null;\n    } else {\n      return validate(props, propName, componentName, location, propFullName);\n    }\n  }\n\n  const chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nexport function propType(\n  doc: DocumentNode,\n  mapPropsToVariables = props => null,\n) {\n  return createChainableTypeChecker((props, propName) => {\n    const prop = props[propName];\n    try {\n      if (!prop.loading) {\n        check(doc, prop, mapPropsToVariables(props));\n      }\n      return null;\n    } catch (e) {\n      // Need a much better error.\n      // Also we aren't checking for extra fields\n      return e;\n    }\n  });\n}\n", "import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n  field: FieldNode;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues: VariableMap = {},\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (variables && !shouldInclude(selection, variables)) {\n      // Skip selection sets which we're able to determine should not be run\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.alias?.value || field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n    field,\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function merge(dest, src) {\n  if (src !== null && typeof src === 'object') {\n    Object.keys(src).forEach(key => {\n      const srcVal = src[key];\n      if (!hasOwn.call(dest, key)) {\n        dest[key] = srcVal;\n      } else {\n        merge(dest[key], srcVal);\n      }\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
